## 1. HTTP
- 'HyperText Transfer Protocol'의 약자로, 하이퍼미디어 문서를 전송하기 위한 프로토콜입니다.
- 웹에서 이루어지는 데이터 통신의 기초로, 주로 TCP를 사용합니다.

## 2. TCP/IP
- 인터넷에 관련된 다양한 프로토콜의 집합을 총칭합니다.
- HTTP는 TCP/IP중 하나입니다.

### 2.1 TCP/IP 4계층(Layer)
- 4계층(애플리케이션 계층): 유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정합니다.
- 3계층(트랜스포트 계층): 애플리케이션 계층에 네트워크로 접속된 2대의 컴퓨터 사이의 데이터 흐름을 제공합니다. 
- 2계층(네트워크 계층): 네트워크상에서 패킷의 이동을 다룹니다. 여러 가지 길 중에서 하나의 길을 결정하는 역할입니다.
- 1계층(링크 계층): 네트워크에 접속하는 하드웨어적인 면을 다룹니다.

### 2.2 TCP와 UDP
- 각각 Transmission Control Protocol과 User Data Protocol의 약자입니다.
- 주로 웹브라우저들이 웹 서버에 연결할 때 사용합니다.
- TCP의 경우 순서가 보장되지만 상대적으로 느리며, UDP의 경우 순서가 보장되지 않지만 속도가 빠릅니다.

## 3. Protocol
- 데이터가 전송되는 방식을 결정하는 규약입니다.
- 송/수신자 사이의 합의를 통해 데이터 포맷, 오류제어 등 통신할 때의 규칙입니다.

### 3.1 Request와 Response
- **Request**
    - 클라이언트(Web Browser)가 서버에 특정 작업을 요청하는 메시지입니다.
    - 사용자가 특정 웹 페이지에 접근하려고 할 때 웹 서버로 보내집니다.
- **Response**
    - 서버가 클라이언트의 요청에 대해 보내는 메시지입니다.
    - 요청에 대한 결과와 함께, 요청된 리소스를 클라이언트에게 반환합니다.

### 3.2 State
- **Stateful**
    - 항상 같은 서버로 유지함을 의미합니다.
    - 중간에 서버에 장애가 발생하면 문제가 생깁니다.
- **Stateless**
    - 서버를 변경할 수 있으며, 요청마다 필요한 정보를 모두 담아 보내야 합니다.
    - 서버 설계를 단순하게 할 수 있고, 송수신되는 정보 처리를 위한 공간을 동적으로 할당할 수 있습니다.
    - 데이터를 받아오기 위해 새로운 연결을 계속 시도하기 때문에, Cookie 등을 활용합니다. 

## 4. URL
### 4.1 URI
- Uniform Resource Identifier의 약자입니다.
- 리소스를 고유하게 식별하기 위한 범용적인 개념이며, URL와 URN 두 가지 형태로 나뉩니다.

### 4.2 URL
- Uniform Resource Locator의 약자로, 자원이 어디 있는지를 알려주기 위한 규약입니다.
- 웹 사이트를 표시하기 위해 입력하는 주소를 말합니다.
- 웹사이트 주소 뿐만 아니라 **컴퓨터 네트워크상의 모든 자원**을 나타낼 수 있습니다.

### 4.3 URN
- Uniform Resource Name의 약자로, 리소스의 위치에 관계없이 고유하게 식별할 수 있는 **이름**을 나타냅니다.
- 리소스를 특정 이름으로 고유하게 식별하는 데에 사용합니다.

```
URL = Scheme + Host(aka Domain, ://뒤) + port(:뒤) + path(/뒤) + query(?뒤) + fragment(#뒤)
URN = 'urn:isbn:0451450523'
```

### 4.4 URL의 구조
- **Scheme**: 리소스에 접근하는 방식을 정의하는 프로토콜을 나타냅니다. (https://)
- **Host**: 리소스가 위치한 서버의 도메인 이름이나 IP 주소를 나타냅니다. (www.example.com)
- **Port**: 서버에 접근하기 위한 포트 번호를 나타냅니다. 웹에서는 일반적으로 생략 가능하며, 이때 기본값이 적용됩니다. (80->HTTP 기본값, 443->HTTPS 기본값)
- **Path**: 서버 내에서 특정 리소스의 위치를 나타냅니다. 디렉터리 구조를 따르며, 파일 경로 방식과 유사합니다. (/path/to/resource)
- **Query**: 서버에 추가 정보를 전달하기 위해 사용됩니다. 주로 키-값 쌍으로 이루어진 파라미터들이 포함됩니다. (?key1=value1&key2=value2)
- **Fragment**: 문서 내에서 특정 부분으로의 이동을 지정합니다. 클라이언트 측에서만 사용되며, 서버로 전송되지 않습니다. (#section2)

## 5. HTTP 메시지 구조
### 5.1 Request

```
GET /index.html HTTP/1.1
user-agent: MSIE 6.0; Windows NT 5.0
accept: text/html; */*
cookie: name = value
referer: http://www.naver.com
host: www.paullab.co.kr
```
- 요청 메서드, 기본 페이지, 프로토콜 버전
- **User-Agent**: 사용자 웹 브라우저 종류 및 버전 정보
- **Accept**: 웹 서버로부터 수신되는 데이터 중 웹 브라우저가 처리할 수 있는 데이터 타입
- **Cookie**: 로그인 인증을 위하여 사용자 정보를 기억하려고 만든 인위적인 값
- **Referer**: 현재 페이지 접속 전에 어느 사이트를 경유했는지 알려주는 도메인 혹은 URL 정보
- **Host**: 사용자가 요청한 도메인 정보

### 5.2 HTTP 요청 메서드

|||
|:---|:---|
|**GET**|리소스 취득(? 뒤에 이어붙이는 방식)|
|**POST**|리소스 생성(Body에 붙이는 방식)|
|**PUT**|리소스의 모든 것을 업데이트|
|**DELETE**|리소스 삭제|
|**PATCH**|리소스의 일부를 업데이트|
|HEAD|HTTP 헤더 정보만 요청, 해당 자원 존재 여부 확인 목적. GET과 비슷하지만 Response Body를 반환하지 않음.|
|OPTIONS|웹서버가 지원하는 메서드 종류 반환 요청|
|TRACE|요청 리소스가 수신되는 경로 확인|
|CONNECT|요청 리소스에 대해 양방향 연결 시|

### 5.3 Response
```
HTTP/1.1 200 OK
Server: NCSA/1.4.2
Content-type: text/html
Content-length: 107

<html>
...
</html>
```
- 웹 프로토콜 버전 및 응답 코드 정보가 포함
- 웹 애플리케이션 종류 및 버전 정보가 포함
- MIME 타입 정보가 포함
- 수신 Body 사이즈 정보가 포함
- 사용자가 요청한 웹 페이지 정보가 포함

### 5.4 응답 결과 상태코드
|2xx||3xx||4xx||5xx||
|:---|:---|:---|:---|:---|:---|:---|:---|
|**200**|**서버가 요청을 제대로 처리**|301|요청한 페이지를 새 위치로 영구적으로 이동|**400**|**Bad Request. 잘못된 요청**|500|서버에 오류가 발생하여 요청을 수행할 수 없음|
|201|성공적으로 요청되었으며 서버가 새 리소스를 작성|||401|Unauthorized. 권한 없이 요청.|**503**|**서버가 오버로드되었거나 유지관리를 위해 다운된 상태.**|
|202|서버가 요청을 접수했지만 아직 처리하지 않음|||**403**|**Forbidden. 서버가 요청을 거부.**|||
|||||**404**|**서버가 요청한 페이지를 찾을 수 없음.**|||

## 6. HTTPS

    HTTP + 암호화 + 인증 + 완전성 보호 = HTTPS

### 6.1 HTTP와 HTTPS의 다른 점
- HTTPS는 암호화로 도청을 피할 수 있습니다.
    - HTTP는 암호화되지 않은 평문의 통신이기 때문에 도청될 수 있습니다.
    - 통신 암화화. SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)이라는 다른 프로토콜을 조합하여 HTTP를 암호화합니다.

- HTTPS는 통신 상대를 확인합니다.
    - HTTP는 통신 상대를 확인하지 않기 때문에 위장할 수 있습니다.
    - SSL은 암호화뿐만이 아니라 통신 상대를 확인하는 수단으로 증명서를 제공합니다.
    - 증명서는 신뢰할 수 있는 기관에 의해 발행되기 때문에 서버나 클라이언트의 실재를 증명해줍니다. 이는 위조가 상당이 어렵습니다.
    - 통신 상대가 내가 통신하고자 하는 상대인지 아닌지를 판단할 수 있습니다.

- HTTPS는 변조를 방지할 수 있습니다.
    - HTTP는 완전성을 증명할 수 없으므로, 중간에 변조가 되었다고 해도 알아차리지 못합니다.
    - 통신 중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자(MITM, Man-in-the-Middle) 공격이라고 부릅니다.
    - 현재 변조 방지를 위한 방식은 MD5(깨졌습니다), SHA-1(위험합니다), SHA-2(아직은 안전합니다) 등의 해시값 확인 혹은 파일의 디지털 서명을 확인하는 방법이 있습니다. 완벽하진 않습니다.
    - SSL에는 인증이나 암호화, 그리고 강화된 인증 기능을 제공합니다.

### 6.2 HTTPS의 문제점
 - CPU나 메모리 등 리소스가 많이 필요합니다. 계속된다면 부하가 발생할 가능성이 있습니다.
 - 증명서 가격, 유지비용 등 추가로 비용이 발생할 수 있습니다.
 - 이 모두를 고려하여, 모든 컨텐츠를 암호화하는 것이 아닌, 꼭 필요한 정보(로그인, 개인 정보)만 암호화 함으로써 리소스를 절약하는 방법도 있습니다.
